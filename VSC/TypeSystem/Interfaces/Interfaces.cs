using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using VSC.Context;

namespace VSC.TypeSystem.Interfaces
{

    /// <summary>
    /// Interface for TypeSystem objects that support interning.
    /// See <see cref="InterningProvider"/> for more information.
    /// </summary>
    public interface ISupportsInterning
    {
        /// <summary>
        /// Gets a hash code for interning.
        /// </summary>
        int GetHashCodeForInterning();

        /// <summary>
        /// Equality test for interning.
        /// </summary>
        bool EqualsForInterning(ISupportsInterning other);
    }
    /// <summary>
    /// Represents an unresolved attribute.
    /// </summary>
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
    public interface IUnresolvedAttribute
    {
        /// <summary>
        /// Gets the code region of this attribute.
        /// </summary>
        Location Region { get; }

        /// <summary>
        /// Resolves the attribute.
        /// </summary>
        IAttribute CreateResolvedAttribute(ITypeResolveContext context);
    }

    /// <summary>
    /// Represents an attribute.
    /// </summary>
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Microsoft.Naming", "CA1711:IdentifiersShouldNotHaveIncorrectSuffix")]
    public interface IAttribute
    {
        /// <summary>
        /// Gets the type of the attribute.
        /// </summary>
        IType AttributeType { get; }

        /// <summary>
        /// Gets the constructor being used.
        /// This property may return null if no matching constructor was found.
        /// </summary>
        IMethod Constructor { get; }

        /// <summary>
        /// Gets the positional arguments.
        /// </summary>
        IList<object> PositionalArguments { get; }

        ///// <summary>
        ///// Gets the named arguments passed to the attribute.
        ///// </summary>
        //IList<KeyValuePair<IMember, ResolveResult>> NamedArguments { get; }
    }

    /// <summary>
    /// Represents an unresolved constant value.
    /// </summary>
    public interface IConstantValue
    {
        /// <summary>
        /// Resolves the value of this constant.
        /// </summary>
        /// <param name="context">Context where the constant value will be used.</param>
        /// <returns>Resolve result representing the constant value.
        /// This method never returns null; in case of errors, an ErrorResolveResult will be returned.</returns>
        object Resolve(ITypeResolveContext context);
    }

    /// <summary>
    /// Represents an unresolved entity.
    /// </summary>
    public interface IUnresolvedEntity : INamedElement, IHasAccessibility
    {
        /// <summary>
        /// Gets the entity type.
        /// </summary>
        SymbolKind SymbolKind { get; }

        /// <summary>
        /// Gets the complete entity region (including header+body)
        /// </summary>
        Location Region { get; }

        /// <summary>
        /// Gets the entity body region.
        /// </summary>
        Location BodyRegion { get; }

        /// <summary>
        /// Gets the declaring class.
        /// For members, this is the class that contains the member.
        /// For nested classes, this is the outer class. For top-level entities, this property returns null.
        /// </summary>
        IUnresolvedTypeDefinition DeclaringTypeDefinition { get; }

        /// <summary>
        /// Gets the parsed file in which this entity is defined.
        /// Returns null if this entity wasn't parsed from source code (e.g. loaded from a .dll with CecilLoader).
        /// </summary>
        IUnresolvedFile UnresolvedFile { get; }

        /// <summary>
        /// Gets the attributes on this entity.
        /// </summary>
        IList<IUnresolvedAttribute> Attributes { get; }

        /// <summary>
        /// Gets whether this entity is static.
        /// Returns true if either the 'static' or the 'const' modifier is set.
        /// </summary>
        bool IsStatic { get; }

        /// <summary>
        /// Returns whether this entity is abstract.
        /// </summary>
        /// <remarks>Static classes also count as abstract classes.</remarks>
        bool IsAbstract { get; }

        /// <summary>
        /// Returns whether this entity is sealed.
        /// </summary>
        /// <remarks>Static classes also count as sealed classes.</remarks>
        bool IsSealed { get; }

        /// <summary>
        /// Gets whether this member is declared to be shadowing another member with the same name.
        /// </summary>
        bool IsShadowing { get; }

        /// <summary>
        /// Gets whether this member is generated by a macro/compiler feature.
        /// </summary>
        bool IsSynthetic { get; }
    }

    /// <summary>
    /// Represents a resolved entity.
    /// </summary>
    public interface IEntity : ISymbol, ICompilationProvider, INamedElement, IHasAccessibility
    {
        /// <summary>
        /// Gets the short name of the entity.
        /// </summary>
        new string Name { get; }

        /// <summary>
        /// Gets the complete entity region (including header+body)
        /// </summary>
        Location Region { get; }

        /// <summary>
        /// Gets the entity body region.
        /// </summary>
        Location BodyRegion { get; }

        /// <summary>
        /// Gets the declaring class.
        /// For members, this is the class that contains the member.
        /// For nested classes, this is the outer class. For top-level entities, this property returns null.
        /// </summary>
        ITypeDefinition DeclaringTypeDefinition { get; }

        /// <summary>
        /// Gets/Sets the declaring type (incl. type arguments, if any).
        /// This property will return null for top-level entities.
        /// If this is not a specialized member, the value returned is equal to <see cref="DeclaringTypeDefinition"/>.
        /// </summary>
        IType DeclaringType { get; }

        /// <summary>
        /// Gets the attributes on this entity.
        /// </summary>
        IList<IAttribute> Attributes { get; }
        /// <summary>
        /// Gets whether this entity is static.
        /// Returns true if either the 'static' or the 'const' modifier is set.
        /// </summary>
        bool IsStatic { get; }

        /// <summary>
        /// Returns whether this entity is abstract.
        /// </summary>
        /// <remarks>Static classes also count as abstract classes.</remarks>
        bool IsAbstract { get; }

        /// <summary>
        /// Returns whether this entity is sealed.
        /// </summary>
        /// <remarks>Static classes also count as sealed classes.</remarks>
        bool IsSealed { get; }

        /// <summary>
        /// Gets whether this member is declared to be shadowing another member with the same name.
        /// (V# 'new' keyword)
        /// </summary>
        bool IsShadowing { get; }

        /// <summary>
        /// Gets whether this member is generated by a macro/compiler feature.
        /// </summary>
        bool IsSynthetic { get; }
    }

    public interface IUnresolvedEvent : IUnresolvedMember
    {
        bool CanAdd { get; }
        bool CanRemove { get; }
        bool CanInvoke { get; }

        IUnresolvedMethod AddAccessor { get; }
        IUnresolvedMethod RemoveAccessor { get; }
        IUnresolvedMethod InvokeAccessor { get; }

        /// <summary>
        /// Resolves the member.
        /// </summary>
        /// <param name="context">
        /// Context for looking up the member. The context must specify the current assembly.
        /// A <see cref="SimpleTypeResolveContext"/> that specifies the current assembly is sufficient.
        /// </param>
        /// <returns>
        /// Returns the resolved member, or <c>null</c> if the member could not be found.
        /// </returns>
        new IEvent Resolve(ITypeResolveContext context);
    }
    public interface IEvent : IMember
    {
        bool CanAdd { get; }
        bool CanRemove { get; }
        bool CanInvoke { get; }

        IMethod AddAccessor { get; }
        IMethod RemoveAccessor { get; }
        IMethod InvokeAccessor { get; }
    }

    /// <summary>
    /// Represents a field or constant.
    /// </summary>
    public interface IUnresolvedField : IUnresolvedMember
    {
        /// <summary>
        /// Gets whether this field is readonly.
        /// </summary>
        bool IsReadOnly { get; }



        /// <summary>
        /// Gets whether this field is a constant (V#-like const).
        /// </summary>
        bool IsConst { get; }



        IConstantValue ConstantValue { get; }

        /// <summary>
        /// Resolves the member.
        /// </summary>
        /// <param name="context">
        /// Context for looking up the member. The context must specify the current assembly.
        /// A <see cref="SimpleTypeResolveContext"/> that specifies the current assembly is sufficient.
        /// </param>
        /// <returns>
        /// Returns the resolved member, or <c>null</c> if the member could not be found.
        /// </returns>
        new IField Resolve(ITypeResolveContext context);
    }
    /// <summary>
    /// Represents a field or constant.
    /// </summary>
    public interface IField : IMember, IVariable
    {
        /// <summary>
        /// Gets the name of the field.
        /// </summary>
        new string Name { get; } // solve ambiguity between IMember.Name and IVariable.Name

        /// <summary>
        /// Gets the region where the field is declared.
        /// </summary>
        new Location Region { get; } // solve ambiguity between IEntity.Region and IVariable.Region

        /// <summary>
        /// Gets whether this field is readonly.
        /// </summary>
        bool IsReadOnly { get; }

        new IMemberReference ToReference(); // solve ambiguity between IMember.ToReference() and IVariable.ToReference()
    }


    /// <summary>
    /// Method/field/property/event.
    /// </summary>
    public interface IUnresolvedMember : IUnresolvedEntity, IMemberReference
    {
        /// <summary>
        /// Gets the return type of this member.
        /// This property never returns null.
        /// </summary>
        ITypeReference ReturnType { get; }

        /// <summary>
        /// Gets whether this member is explicitly implementing an interface.
        /// If this property is true, the member can only be called through the interfaces it implements.
        /// </summary>
        bool IsExplicitInterfaceImplementation { get; }

        /// <summary>
        /// Gets the interfaces that are explicitly implemented by this member.
        /// </summary>
        IList<IMemberReference> ExplicitInterfaceImplementations { get; }

        /// <summary>
        /// Gets if the member is virtual. Is true only if the "virtual" modifier was used, but non-virtual
        /// members can be overridden, too; if they are abstract or overriding a method.
        /// </summary>
        bool IsVirtual { get; }

        /// <summary>
        /// Gets whether this member is overriding another member.
        /// </summary>
        bool IsOverride { get; }

        /// <summary>
        /// Gets if the member can be overridden. Returns true when the member is "abstract", "virtual" or "override" but not "sealed".
        /// </summary>
        bool IsOverridable { get; }

        /// <summary>
        /// Resolves the member.
        /// </summary>
        /// <param name="context">
        /// Context for looking up the member. The context must specify the current assembly.
        /// A <see cref="SimpleTypeResolveContext"/> that specifies the current assembly is sufficient.
        /// </param>
        /// <returns>
        /// Returns the resolved member, or <c>null</c> if the member could not be found.
        /// </returns>
        new IMember Resolve(ITypeResolveContext context);

        /// <summary>
        /// Creates the resolved member.
        /// </summary>
        /// <param name="context">
        /// The language-specific context that includes the parent type definition.
        /// <see cref="IUnresolvedTypeDefinition.CreateResolveContext"/>
        /// </param>
        IMember CreateResolved(ITypeResolveContext context);
    }
    public interface IMemberReference : ISymbolReference
    {
        /// <summary>
        /// Gets the declaring type reference for the member.
        /// </summary>
        ITypeReference DeclaringTypeReference { get; }

        /// <summary>
        /// Resolves the member.
        /// </summary>
        /// <param name="context">
        /// Context to use for resolving this member reference.
        /// Which kind of context is required depends on the which kind of member reference this is;
        /// please consult the documentation of the method that was used to create this member reference,
        /// or that of the class implementing this method.
        /// </param>
        /// <returns>
        /// Returns the resolved member, or <c>null</c> if the member could not be found.
        /// </returns>
        new IMember Resolve(ITypeResolveContext context);
    }
    /// <summary>
    /// Method/field/property/event.
    /// </summary>
    public interface IMember : IEntity
    {
        /// <summary>
        /// Gets the original member definition for this member.
        /// Returns <c>this</c> if this is not a specialized member.
        /// Specialized members are the result of overload resolution with type substitution.
        /// </summary>
        IMember MemberDefinition { get; }

        /// <summary>
        /// Gets the unresolved member instance from which this member was created.
        /// This property may return <c>null</c> for special members that do not have a corresponding unresolved member instance.
        /// </summary>
        /// <remarks>
        /// For specialized members, this property returns the unresolved member for the original member definition.
        /// For partial methods, this property returns the implementing partial method declaration, if one exists, and the
        /// defining partial method declaration otherwise.
        /// For the members used to represent the built-in C# operators like "operator +(int, int);", this property returns <c>null</c>.
        /// </remarks>
        IUnresolvedMember UnresolvedMember { get; }

        /// <summary>
        /// Gets the return type of this member.
        /// This property never returns <c>null</c>.
        /// </summary>
        IType ReturnType { get; }

        /// <summary>
        /// Gets the interface members implemented by this member (both implicitly and explicitly).
        /// </summary>
        IList<IMember> ImplementedInterfaceMembers { get; }

        /// <summary>
        /// Gets whether this member is explicitly implementing an interface.
        /// </summary>
        bool IsExplicitInterfaceImplementation { get; }

        /// <summary>
        /// Gets if the member is virtual. Is true only if the "virtual" modifier was used, but non-virtual
        /// members can be overridden, too; if they are abstract or overriding a method.
        /// </summary>
        bool IsVirtual { get; }

        /// <summary>
        /// Gets whether this member is overriding another member.
        /// </summary>
        bool IsOverride { get; }

        /// <summary>
        /// Gets if the member can be overridden. Returns true when the member is "abstract", "virtual" or "override" but not "sealed".
        /// </summary>
        bool IsOverridable { get; }


        /// <summary>
        /// Creates a member reference that can be used to rediscover this member in another compilation.
        /// </summary>
        /// <remarks>
        /// If this member is specialized using open generic types, the resulting member reference will need to be looked up in an appropriate generic context.
        /// Otherwise, the main resolve context of a compilation is sufficient.
        /// </remarks>
        new IMemberReference ToReference();


     
    }

    public interface IUnresolvedMethod : IUnresolvedParameterizedMember
    {
        /// <summary>
        /// Gets the attributes associated with the return type. (e.g. [return: MarshalAs(...)])
        /// </summary>
        IList<IUnresolvedAttribute> ReturnTypeAttributes { get; }

        IList<IUnresolvedTypeParameter> TypeParameters { get; }

        bool IsConstructor { get; }
        bool IsDestructor { get; }
        bool IsOperator { get; }


        /// <summary>
        /// Gets whether the method has a body.
        /// This property returns <c>false</c> for <c>abstract</c> or <c>extern</c> methods,
        /// or for <c>partial</c> methods without implementation.
        /// </summary>
        bool HasBody { get; }

        /// <summary>
        /// If this method is an accessor, returns a reference to the corresponding property/event.
        /// Otherwise, returns null.
        /// </summary>
        IUnresolvedMember AccessorOwner { get; }

        /// <summary>
        /// Resolves the member.
        /// </summary>
        /// <param name="context">
        /// Context for looking up the member. The context must specify the current assembly.
        /// A <see cref="SimpleTypeResolveContext"/> that specifies the current assembly is sufficient.
        /// </param>
        /// <returns>
        /// Returns the resolved member, or <c>null</c> if the member could not be found.
        /// </returns>
        new IMethod Resolve(ITypeResolveContext context);
    }
    /// <summary>
    /// Represents a method, constructor, destructor or operator.
    /// </summary>
    public interface IMethod : IParameterizedMember
    {
       

        /// <summary>
        /// Gets the attributes associated with the return type. (e.g. [return: MarshalAs(...)])
        /// NOTE: The type will change to IReadOnlyList&lt;IAttribute&gt; in future versions.
        /// </summary>
        IList<IAttribute> ReturnTypeAttributes { get; }

        /// <summary>
        /// Gets the type parameters of this method; or an empty list if the method is not generic.
        /// NOTE: The type will change to IReadOnlyList&lt;ITypeParameter&gt; in future versions.
        /// </summary>
        IList<ITypeParameter> TypeParameters { get; }

        /// <summary>
        /// Gets whether this is a generic method that has been parameterized.
        /// </summary>
        bool IsParameterized { get; }

        /// <summary>
        /// Gets the type arguments passed to this method.
        /// If the method is generic but not parameterized yet, this property returns the type parameters,
        /// as if the method was parameterized with its own type arguments (<c>void M&lt;T&gt;() { M&lt;T&gt;(); }</c>).
        /// 
        /// NOTE: The type will change to IReadOnlyList&lt;IType&gt; in future versions.
        /// </summary>
        IList<IType> TypeArguments { get; }

        bool IsExtensionMethod { get; }
        bool IsConstructor { get; }
        bool IsDestructor { get; }
        bool IsOperator { get; }



        /// <summary>
        /// Gets whether the method has a body.
        /// This property returns <c>false</c> for <c>abstract</c> or <c>extern</c> methods,
        /// or for <c>partial</c> methods without implementation.
        /// </summary>
        bool HasBody { get; }

        /// <summary>
        /// Gets whether the method is a property/event accessor.
        /// </summary>
        bool IsAccessor { get; }

        /// <summary>
        /// If this method is an accessor, returns the corresponding property/event.
        /// Otherwise, returns null.
        /// </summary>
        IMember AccessorOwner { get; }

    
    }

    public interface INamedElement
    {
        /// <summary>
        /// Gets the fully qualified name of the class the return type is pointing to.
        /// </summary>
        /// <returns>
        /// "System.Int32[]" for int[]<br/>
        /// "System.Collections.Generic.List" for List&lt;string&gt;
        /// "System.Environment.SpecialFolder" for Environment.SpecialFolder
        /// </returns>
        string FullName { get; }

        /// <summary>
        /// Gets the short name of the class the return type is pointing to.
        /// </summary>
        /// <returns>
        /// "Int32[]" for int[]<br/>
        /// "List" for List&lt;string&gt;
        /// "SpecialFolder" for Environment.SpecialFolder
        /// </returns>
        string Name { get; }

        /// <summary>
        /// Gets the full reflection name of the element.
        /// </summary>
        /// <remarks>
        /// For types, the reflection name can be parsed back into a ITypeReference by using
        /// <see cref="ReflectionHelper.ParseReflectionName(string)"/>.
        /// </remarks>
        /// <returns>
        /// "System.Int32[]" for int[]<br/>
        /// "System.Int32[][,]" for C# int[,][]<br/>
        /// "System.Collections.Generic.List`1[[System.String]]" for List&lt;string&gt;
        /// "System.Environment+SpecialFolder" for Environment.SpecialFolder
        /// </returns>
        string ReflectionName { get; }

        /// <summary>
        /// Gets the full name of the namespace containing this entity.
        /// </summary>
        string Namespace { get; }
    }
    /// <summary>
    /// Represents a resolved namespace.
    /// </summary>
    public interface INamespace : ISymbol, ICompilationProvider
    {
        // No pointer back to unresolved namespace:
        // multiple unresolved namespaces (from different assemblies) get
        // merged into one INamespace.


        /// <summary>
        /// Gets the full name of this namespace. (e.g. "System.Collections")
        /// </summary>
        string FullName { get; }

        /// <summary>
        /// Gets the short name of this namespace (e.g. "Collections").
        /// </summary>
        new string Name { get; }

        /// <summary>
        /// Gets the parent namespace.
        /// Returns null if this is the root namespace.
        /// </summary>
        INamespace ParentNamespace { get; }

        /// <summary>
        /// Gets the child namespaces in this namespace.
        /// </summary>
        IEnumerable<INamespace> ChildNamespaces { get; }

        /// <summary>
        /// Gets the types in this namespace.
        /// </summary>
        IEnumerable<ITypeDefinition> Types { get; }


        /// <summary>
        /// Gets a direct child namespace by its short name.
        /// Returns null when the namespace cannot be found.
        /// </summary>
        /// <remarks>
        /// This method uses the compilation's current string comparer.
        /// </remarks>
        INamespace GetChildNamespace(string name);

        /// <summary>
        /// Gets the type with the specified short name and type parameter count.
        /// Returns null if the type cannot be found.
        /// </summary>
        /// <remarks>
        /// This method uses the compilation's current string comparer.
        /// </remarks>
        ITypeDefinition GetTypeDefinition(string name, int typeParameterCount);
    }

    public interface IUnresolvedParameter
    {
        /// <summary>
        /// Gets the name of the variable.
        /// </summary>
        string Name { get; }

        /// <summary>
        /// Gets the declaration region of the variable.
        /// </summary>
        Location Region { get; }

        /// <summary>
        /// Gets the type of the variable.
        /// </summary>
        ITypeReference Type { get; }

        /// <summary>
        /// Gets the list of attributes.
        /// </summary>
        IList<IUnresolvedAttribute> Attributes { get; }

        /// <summary>
        /// Gets whether this parameter is a C# 'ref' parameter.
        /// </summary>
        bool IsRef { get; }

        /// <summary>
        /// Gets whether this parameter is a C# 'out' parameter.
        /// </summary>
        bool IsOut { get; }

        /// <summary>
        /// Gets whether this parameter is a C# 'params' parameter.
        /// </summary>
        bool IsParams { get; }

        /// <summary>
        /// Gets whether this parameter is optional.
        /// </summary>
        bool IsOptional { get; }

        IParameter CreateResolvedParameter(ITypeResolveContext context);
    }
    public interface IParameter : IVariable
    {
        /// <summary>
        /// Gets the list of attributes.
        /// </summary>
        IList<IAttribute> Attributes { get; }

        /// <summary>
        /// Gets whether this parameter is a C# 'ref' parameter.
        /// </summary>
        bool IsRef { get; }

        /// <summary>
        /// Gets whether this parameter is a C# 'out' parameter.
        /// </summary>
        bool IsOut { get; }

        /// <summary>
        /// Gets whether this parameter is a C# 'params' parameter.
        /// </summary>
        bool IsParams { get; }

        /// <summary>
        /// Gets whether this parameter is optional.
        /// The default value is given by the <see cref="IVariable.ConstantValue"/> property.
        /// </summary>
        bool IsOptional { get; }

        /// <summary>
        /// Gets the owner of this parameter.
        /// May return null; for example when parameters belong to lambdas or anonymous methods.
        /// </summary>
        IParameterizedMember Owner { get; }
    }

    /// <summary>
    /// Represents a method or property.
    /// </summary>
    public interface IUnresolvedParameterizedMember : IUnresolvedMember
    {
        IList<IUnresolvedParameter> Parameters { get; }
    }
    /// <summary>
    /// Represents a method or property.
    /// </summary>
    public interface IParameterizedMember : IMember
    {
        IList<IParameter> Parameters { get; }
    }

    /// <summary>
    /// Represents a property or indexer.
    /// </summary>
    public interface IUnresolvedProperty : IUnresolvedParameterizedMember
    {
        bool CanGet { get; }
        bool CanSet { get; }

        IUnresolvedMethod Getter { get; }
        IUnresolvedMethod Setter { get; }

        bool IsIndexer { get; }

        /// <summary>
        /// Resolves the member.
        /// </summary>
        /// <param name="context">
        /// Context for looking up the member. The context must specify the current assembly.
        /// A <see cref="SimpleTypeResolveContext"/> that specifies the current assembly is sufficient.
        /// </param>
        /// <returns>
        /// Returns the resolved member, or <c>null</c> if the member could not be found.
        /// </returns>
        new IProperty Resolve(ITypeResolveContext context);
    }
    /// <summary>
    /// Represents a property or indexer.
    /// </summary>
    public interface IProperty : IParameterizedMember
    {
        bool CanGet { get; }
        bool CanSet { get; }

        IMethod Getter { get; }
        IMethod Setter { get; }

        bool IsIndexer { get; }
    }

    public enum SymbolKind : byte
    {
        None,
        /// <seealso cref="ITypeDefinition"/>
        TypeDefinition,
        /// <seealso cref="IField"/>
        Field,
        /// <summary>
        /// The symbol is a property, but not an indexer.
        /// </summary>
        /// <seealso cref="IProperty"/>
        Property,
        /// <summary>
        /// The symbol is an indexer, not a regular property.
        /// </summary>
        /// <seealso cref="IProperty"/>
        Indexer,
        /// <seealso cref="IEvent"/>
        Event,
        /// <summary>
        /// The symbol is a method which is not an operator/constructor/destructor or accessor.
        /// </summary>
        /// <seealso cref="IMethod"/>
        Method,
        /// <summary>
        /// The symbol is a user-defined operator.
        /// </summary>
        /// <seealso cref="IMethod"/>
        Operator,
        /// <seealso cref="IMethod"/>
        Constructor,
        /// <seealso cref="IMethod"/>
        Destructor,
        /// <summary>
        /// The accessor method for a property getter/setter or event add/remove.
        /// </summary>
        /// <seealso cref="IMethod"/>
        Accessor,
        /// <seealso cref="INamespace"/>
        Namespace,
        /// <summary>
        /// The symbol is a variable, but not a parameter.
        /// </summary>
        /// <seealso cref="IVariable"/>
        Variable,
        /// <seealso cref="IParameter"/>
        Parameter,
        /// <seealso cref="ITypeParameter"/>
        TypeParameter,
    }
    /// <summary>
    /// Interface for type system symbols.
    /// </summary>
    public interface ISymbol
    {
        /// <summary>
        /// This property returns an enum specifying which kind of symbol this is
        /// (which derived interfaces of ISymbol are implemented)
        /// </summary>
        SymbolKind SymbolKind { get; }

        /// <summary>
        /// Gets the short name of the symbol.
        /// </summary>
        string Name { get; }

        /// <summary>
        /// Creates a symbol reference that can be used to rediscover this symbol in another compilation.
        /// </summary>
        ISymbolReference ToReference();
    }
    public interface ISymbolReference
    {
        ISymbol Resolve(ITypeResolveContext context);
    }

    /// <summary>
    /// This interface represents a resolved type in the type system.
    /// </summary>
    /// <remarks>
    /// <para>
    /// A type is potentially
    /// - a type definition (<see cref="ITypeDefinition"/>, i.e. a class, struct, interface, delegate, or built-in primitive type)
    /// - a parameterized type (<see cref="ParameterizedType"/>, e.g. List&lt;int>)
    /// - a type parameter (<see cref="ITypeParameter"/>, e.g. T)
    /// - an array (<see cref="ArrayType"/>)
    /// - a pointer (<see cref="PointerType"/>)
    /// - a managed reference (<see cref="ByReferenceType"/>)
    /// - one of the special types (<see cref="SpecialTypeSpec.UnknownType"/>, <see cref="SpecialTypeSpec.NullType"/>,
    ///      <see cref="SpecialTypeSpec.Dynamic"/>, <see cref="SpecialTypeSpec.UnboundTypeArgument"/>)
    /// 
    /// The <see cref="IType.Kind"/> property can be used to switch on the kind of a type.
    /// </para>
    /// <para>
    /// IType uses the null object pattern: <see cref="SpecialTypeSpec.UnknownType"/> serves as the null object.
    /// Methods or properties returning IType never return null unless documented otherwise.
    /// </para>
    /// <para>
    /// Types should be compared for equality using the <see cref="IEquatable{IType}.Equals(IType)"/> method.
    /// Identical types do not necessarily use the same object reference.
    /// </para>
    /// </remarks>
    public interface IType : INamedElement, IEquatable<IType>
    {
        /// <summary>
        /// Gets the type kind.
        /// </summary>
        TypeKind Kind { get; }

        /// <summary>
        /// Gets whether the type is a reference type or value type.
        /// </summary>
        /// <returns>
        /// true, if the type is a reference type.
        /// false, if the type is a value type.
        /// null, if the type is not known (e.g. unconstrained generic type parameter or type not found)
        /// </returns>
        bool? IsReferenceType { get; }

        /// <summary>
        /// Gets the underlying type definition.
        /// Can return null for types which do not have a type definition (for example arrays, pointers, type parameters).
        /// </summary>
        ITypeDefinition GetDefinition();

        /// <summary>
        /// Gets the parent type, if this is a nested type.
        /// Returns null for top-level types.
        /// </summary>
        IType DeclaringType { get; }

        /// <summary>
        /// Gets the number of type parameters.
        /// </summary>
        int TypeParameterCount { get; }

        /// <summary>
        /// Gets the type arguments passed to this type.
        /// If this type is a generic type definition that is not parameterized, this property returns the type parameters,
        /// as if the type was parameterized with its own type arguments (<c>class C&lt;T&gt; { C&lt;T&gt; field; }</c>).
        /// 
        /// NOTE: The type will change to IReadOnlyList&lt;IType&gt; in future versions.
        /// </summary>
        IList<IType> TypeArguments { get; }

        /// <summary>
        /// If true the type represents an instance of a generic type.
        /// </summary>
        bool IsParameterized { get; }

        /// <summary>
        /// Gets the direct base types.
        /// </summary>
        /// <returns>Returns the direct base types including interfaces</returns>
        IEnumerable<IType> DirectBaseTypes { get; }

        /// <summary>
        /// Creates a type reference that can be used to look up a type equivalent to this type in another compilation.
        /// </summary>
        /// <remarks>
        /// If this type contains open generics, the resulting type reference will need to be looked up in an appropriate generic context.
        /// Otherwise, the main resolve context of a compilation is sufficient.
        /// </remarks>
        ITypeReference ToTypeReference();



        /// <summary>
        /// Gets all instance constructors for this type.
        /// </summary>
        /// <param name="filter">The filter used to select which constructors to return.
        /// The filter is tested on the original method definitions (before specialization).</param>
        /// <param name="options">Specified additional options for the GetMembers() operation.</param>
        /// <remarks>
        /// <para>The result does not include static constructors.
        /// Constructors in base classes are not returned by default, as GetMemberOptions.IgnoreInheritedMembers is the default value.</para>
        /// <para>
        /// For methods on parameterized types, type substitution will be performed on the method signature,
        /// and the appropriate <see cref="Implementation.SpecializedMethod"/> will be returned.
        /// </para>
        /// </remarks>
        IEnumerable<IMethod> GetConstructors(Predicate<IUnresolvedMethod> filter = null, GetMemberOptions options = GetMemberOptions.IgnoreInheritedMembers);

        /// <summary>
        /// Gets all methods that can be called on this type.
        /// </summary>
        /// <param name="filter">The filter used to select which methods to return.
        /// The filter is tested on the original method definitions (before specialization).</param>
        /// <param name="options">Specified additional options for the GetMembers() operation.</param>
        /// <remarks>
        /// <para>
        /// The result does not include constructors or accessors.
        /// </para>
        /// <para>
        /// For methods on parameterized types, type substitution will be performed on the method signature,
        /// and the appropriate <see cref="Implementation.SpecializedMethod"/> will be returned.
        /// </para>
        /// <para>
        /// If the method being returned is generic, and this type is a parameterized type where the type
        /// arguments involve another method's type parameters, the resulting specialized signature
        /// will be ambiguous as to which method a type parameter belongs to.
        /// For example, "List[[``0]].GetMethods()" will return "ConvertAll(Converter`2[[``0, ``0]])".
        /// 
        /// If possible, use the other GetMethods() overload to supply type arguments to the method,
        /// so that both class and method type parameter can be substituted at the same time, so that
        /// the ambiguity can be avoided.
        /// </para>
        /// </remarks>
        IEnumerable<IMethod> GetMethods(Predicate<IUnresolvedMethod> filter = null, GetMemberOptions options = GetMemberOptions.None);

        /// <summary>
        /// Gets all generic methods that can be called on this type with the specified type arguments.
        /// </summary>
        /// <param name="typeArguments">The type arguments used for the method call.</param>
        /// <param name="filter">The filter used to select which methods to return.
        /// The filter is tested on the original method definitions (before specialization).</param>
        /// <param name="options">Specified additional options for the GetMembers() operation.</param>
        /// <remarks>
        /// <para>The result does not include constructors or accessors.</para>
        /// <para>
        /// Type substitution will be performed on the method signature, creating a <see cref="Implementation.SpecializedMethod"/>
        /// with the specified type arguments.
        /// </para>
        /// <para>
        /// When the list of type arguments is empty, this method acts like the GetMethods() overload without
        /// the type arguments parameter - that is, it also returns generic methods,
        /// and the other overload's remarks about ambiguous signatures apply here as well.
        /// </para>
        /// </remarks>
        IEnumerable<IMethod> GetMethods(IList<IType> typeArguments, Predicate<IUnresolvedMethod> filter = null, GetMemberOptions options = GetMemberOptions.None);

        /// <summary>
        /// Gets all properties that can be called on this type.
        /// </summary>
        /// <param name="filter">The filter used to select which properties to return.
        /// The filter is tested on the original property definitions (before specialization).</param>
        /// <param name="options">Specified additional options for the GetMembers() operation.</param>
        /// <remarks>
        /// For properties on parameterized types, type substitution will be performed on the property signature,
        /// and the appropriate <see cref="Implementation.SpecializedProperty"/> will be returned.
        /// </remarks>
        IEnumerable<IProperty> GetProperties(Predicate<IUnresolvedProperty> filter = null, GetMemberOptions options = GetMemberOptions.None);

        /// <summary>
        /// Gets all fields that can be accessed on this type.
        /// </summary>
        /// <param name="filter">The filter used to select which constructors to return.
        /// The filter is tested on the original field definitions (before specialization).</param>
        /// <param name="options">Specified additional options for the GetMembers() operation.</param>
        /// <remarks>
        /// For fields on parameterized types, type substitution will be performed on the field's return type,
        /// and the appropriate <see cref="Implementation.SpecializedField"/> will be returned.
        /// </remarks>
        IEnumerable<IField> GetFields(Predicate<IUnresolvedField> filter = null, GetMemberOptions options = GetMemberOptions.None);

        /// <summary>
        /// Gets all events that can be accessed on this type.
        /// </summary>
        /// <param name="filter">The filter used to select which events to return.
        /// The filter is tested on the original event definitions (before specialization).</param>
        /// <param name="options">Specified additional options for the GetMembers() operation.</param>
        /// <remarks>
        /// For fields on parameterized types, type substitution will be performed on the event's return type,
        /// and the appropriate <see cref="Implementation.SpecializedEvent"/> will be returned.
        /// </remarks>
        IEnumerable<IEvent> GetEvents(Predicate<IUnresolvedEvent> filter = null, GetMemberOptions options = GetMemberOptions.None);

        /// <summary>
        /// Gets all members that can be called on this type.
        /// </summary>
        /// <param name="filter">The filter used to select which members to return.
        /// The filter is tested on the original member definitions (before specialization).</param>
        /// <param name="options">Specified additional options for the GetMembers() operation.</param>
        /// <remarks>
        /// <para>
        /// The resulting list is the union of GetFields(), GetProperties(), GetMethods() and GetEvents().
        /// It does not include constructors.
        /// For parameterized types, type substitution will be performed.
        /// </para>
        /// <para>
        /// For generic methods, the remarks about ambiguous signatures from the
        /// <see cref="GetMethods(Predicate{IUnresolvedMethod}, GetMemberOptions)"/> method apply here as well.
        /// </para>
        /// </remarks>
        IEnumerable<IMember> GetMembers(Predicate<IUnresolvedMember> filter = null, GetMemberOptions options = GetMemberOptions.None);

        /// <summary>
        /// Gets all accessors belonging to properties or events on this type.
        /// </summary>
        /// <param name="filter">The filter used to select which members to return.
        /// The filter is tested on the original member definitions (before specialization).</param>
        /// <param name="options">Specified additional options for the GetMembers() operation.</param>
        /// <remarks>
        /// Accessors are not returned by GetMembers() or GetMethods().
        /// </remarks>
        IEnumerable<IMethod> GetAccessors(Predicate<IUnresolvedMethod> filter = null, GetMemberOptions options = GetMemberOptions.None);
    }
    [Flags]
    public enum GetMemberOptions
    {
        /// <summary>
        /// No options specified - this is the default.
        /// Members will be specialized, and inherited members will be included.
        /// </summary>
        None = 0x00,
        /// <summary>
        /// Do not specialize the returned members - directly return the definitions.
        /// </summary>
        ReturnMemberDefinitions = 0x01,
        /// <summary>
        /// Do not list inherited members - only list members defined directly on this type.
        /// </summary>
        IgnoreInheritedMembers = 0x02
    }


    /// <summary>
    /// Represents an unresolved class, enum, interface, struct, delegate or VB module.
    /// For partial classes, an unresolved type definition represents only a single part.
    /// </summary>
    public interface IUnresolvedTypeDefinition : ITypeReference, IUnresolvedEntity
    {
        TypeKind Kind { get; }

        FullTypeName FullTypeName { get; }
        IList<ITypeReference> BaseTypes { get; }
        IList<IUnresolvedTypeParameter> TypeParameters { get; }

        IList<IUnresolvedTypeDefinition> NestedTypes { get; }
        IList<IUnresolvedMember> Members { get; }

        IEnumerable<IUnresolvedMethod> Methods { get; }
        IEnumerable<IUnresolvedProperty> Properties { get; }
        IEnumerable<IUnresolvedField> Fields { get; }
        IEnumerable<IUnresolvedEvent> Events { get; }

        /// <summary>
        /// Gets whether the type definition contains extension methods.
        /// Returns null when the type definition needs to be resolved in order to determine whether
        /// methods are extension methods.
        /// </summary>
        bool? HasExtensionMethods { get; }

        /// <summary>
        /// Gets whether this unresolved type definition causes the addition of a default constructor
        /// if no other constructor is present.
        /// </summary>
        bool AddDefaultConstructorIfRequired { get; }

        /// <summary>
        /// Looks up the resolved type definition from the <paramref name="context"/> corresponding to this unresolved
        /// type definition.
        /// </summary>
        /// <param name="context">
        /// Context for looking up the type. The context must specify the current assembly.
        /// A <see cref="SimpleTypeResolveContext"/> that specifies the current assembly is sufficient.
        /// </param>
        /// <returns>
        /// Returns the resolved type definition.
        /// In case of an error, returns an <see cref="Implementation.UnknownType"/> instance.
        /// Never returns null.
        /// </returns>
        new IType Resolve(ITypeResolveContext context);

        /// <summary>
        /// This method is used to add language-specific elements like the C# UsingScope
        /// to the type resolve context.
        /// </summary>
        /// <param name="parentContext">The parent context (e.g. the parent assembly),
        /// including the parent type definition for inner classes.</param>
        /// <returns>
        /// The parent context, modified to include language-specific elements (e.g. using scope)
        /// associated with this type definition.
        /// </returns>
        /// <remarks>
        /// Use <c>unresolvedTypeDef.CreateResolveContext(parentContext).WithTypeDefinition(typeDef)</c> to
        /// create the context for use within the type definition.
        /// </remarks>
        ITypeResolveContext CreateResolveContext(ITypeResolveContext parentContext);
    }
    /// <summary>
    /// Represents a class, enum, interface, struct, delegate or VB module.
    /// For partial classes, this represents the whole class.
    /// </summary>
    public interface ITypeDefinition : IType, IEntity
    {
        /// <summary>
        /// Returns all parts that contribute to this type definition.
        /// Non-partial classes have a single part that represents the whole class.
        /// </summary>
        IList<IUnresolvedTypeDefinition> Parts { get; }

        IList<ITypeParameter> TypeParameters { get; }

        IList<ITypeDefinition> NestedTypes { get; }
        IList<IMember> Members { get; }

        IEnumerable<IField> Fields { get; }
        IEnumerable<IMethod> Methods { get; }
        IEnumerable<IProperty> Properties { get; }
        IEnumerable<IEvent> Events { get; }

        /// <summary>
        /// Gets the known type code for this type definition.
        /// </summary>
        KnownTypeCode KnownTypeCode { get; }

        /// <summary>
        /// For enums: returns the underlying primitive type.
        /// For all other types: returns <see cref="SpecialTypeSpec.UnknownType"/>.
        /// </summary>
        IType EnumUnderlyingType { get; }

        /// <summary>
        /// Gets the full name of this type.
        /// </summary>
        FullTypeName FullTypeName { get; }

        /// <summary>
        /// Gets/Sets the declaring type (incl. type arguments, if any).
        /// This property will return null for top-level types.
        /// </summary>
        new IType DeclaringType { get; } // solves ambiguity between IType.DeclaringType and IEntity.DeclaringType

        /// <summary>
        /// Gets whether this type contains extension methods.
        /// </summary>
        /// <remarks>This property is used to speed up the search for extension methods.</remarks>
        bool HasExtensionMethods { get; }


        /// <summary>
        /// Determines how this type is implementing the specified interface member.
        /// </summary>
        /// <returns>
        /// The method on this type that implements the interface member;
        /// or null if the type does not implement the interface.
        /// </returns>
        IMember GetInterfaceImplementation(IMember interfaceMember);

        /// <summary>
        /// Determines how this type is implementing the specified interface members.
        /// </summary>
        /// <returns>
        /// For each interface member, this method returns the class member 
        /// that implements the interface member.
        /// For interface members that are missing an implementation, the
        /// result collection will contain a null element.
        /// </returns>
        IList<IMember> GetInterfaceImplementation(IList<IMember> interfaceMembers);
    }

    /// <summary>
    /// Type parameter of a generic class/method.
    /// </summary>
    public interface IUnresolvedTypeParameter : INamedElement
    {
        /// <summary>
        /// Get the type of this type parameter's owner.
        /// </summary>
        /// <returns>SymbolKind.TypeDefinition or SymbolKind.Method</returns>
        SymbolKind OwnerType { get; }

        /// <summary>
        /// Gets the index of the type parameter in the type parameter list of the owning method/class.
        /// </summary>
        int Index { get; }

        /// <summary>
        /// Gets the region where the type parameter is defined.
        /// </summary>
        Location Region { get; }

        ITypeParameter CreateResolvedTypeParameter(ITypeResolveContext context);
    }
    /// <summary>
    /// Type parameter of a generic class/method.
    /// </summary>
    public interface ITypeParameter : IType, ISymbol
    {
        /// <summary>
        /// Get the type of this type parameter's owner.
        /// </summary>
        /// <returns>SymbolKind.TypeDefinition or SymbolKind.Method</returns>
        SymbolKind OwnerType { get; }

        /// <summary>
        /// Gets the owning method/class.
        /// This property may return null (for example for the dummy type parameters used by <see cref="ParameterListComparer.NormalizeMethodTypeParameters"/>).
        /// </summary>
        /// <remarks>
        /// For "class Outer&lt;T&gt; { class Inner {} }",
        /// inner.TypeParameters[0].Owner will be the outer class, because the same
        /// ITypeParameter instance is used both on Outer`1 and Outer`1+Inner.
        /// </remarks>
        IEntity Owner { get; }

        /// <summary>
        /// Gets the index of the type parameter in the type parameter list of the owning method/class.
        /// </summary>
        int Index { get; }

        /// <summary>
        /// Gets the name of the type parameter.
        /// </summary>
        new string Name { get; }

        /// <summary>
        /// Gets the region where the type parameter is defined.
        /// </summary>
        Location Region { get; }

        /// <summary>
        /// Gets the effective base class of this type parameter.
        /// </summary>
        IType EffectiveBaseClass { get; }

        /// <summary>
        /// Gets the effective interface set of this type parameter.
        /// </summary>
        ICollection<IType> EffectiveInterfaceSet { get; }

        /// <summary>
        /// Gets if the type parameter has the 'class' constraint.
        /// </summary>
        bool HasReferenceTypeConstraint { get; }

        /// <summary>
        /// Gets if the type parameter has the 'struct' constraint.
        /// </summary>
        bool HasValueTypeConstraint { get; }
    }

    /// <summary>
    /// Represents a reference to a type.
    /// Must be resolved before it can be used as type.
    /// </summary>
    public interface ITypeReference
    {
        // Keep this interface simple: I decided against having GetMethods/GetEvents etc. here,
        // so that the Resolve step is never hidden from the consumer.

        // I decided against implementing IFreezable here: IUnresolvedTypeDefinition can be used as ITypeReference,
        // but when freezing the reference, one wouldn't expect the definition to freeze.

        /// <summary>
        /// Resolves this type reference.
        /// </summary>
        /// <param name="context">
        /// Context to use for resolving this type reference.
        /// Which kind of context is required depends on the which kind of type reference this is;
        /// please consult the documentation of the method that was used to create this type reference,
        /// or that of the class implementing this method.
        /// </param>
        /// <returns>
        /// Returns the resolved type.
        /// In case of an error, returns an unknown type (<see cref="TypeKind.Unknown"/>).
        /// Never returns null.
        /// </returns>
        IType Resolve(ITypeResolveContext context);
    }

    /// <summary>
    /// Represents a variable (name/type pair).
    /// </summary>
    public interface IVariable : ISymbol
    {
        /// <summary>
        /// Gets the name of the variable.
        /// </summary>
        new string Name { get; }

        /// <summary>
        /// Gets the declaration region of the variable.
        /// </summary>
        Location Region { get; }

        /// <summary>
        /// Gets the type of the variable.
        /// </summary>
        IType Type { get; }

        /// <summary>
        /// Gets whether this variable is a constant (C#-like const).
        /// </summary>
        bool IsConst { get; }

        /// <summary>
        /// If this field is a constant, retrieves the value.
        /// For parameters, this is the default value.
        /// </summary>
        object ConstantValue { get; }
    }

    /// <summary>
    /// Enum that describes the accessibility of an entity.
    /// </summary>
    public enum Accessibility : byte
    {
        // note: some code depends on the fact that these values are within the range 0-7

        /// <summary>
        /// The entity is completely inaccessible. This is used for C# explicit interface implementations.
        /// </summary>
        None,
        /// <summary>
        /// The entity is only accessible within the same class.
        /// </summary>
        Private,
        /// <summary>
        /// The entity is accessible everywhere.
        /// </summary>
        Public,
        /// <summary>
        /// The entity is only accessible within the same class and in derived classes.
        /// </summary>
        Protected,
        /// <summary>
        /// The entity is accessible within the same project content.
        /// </summary>
        Internal,
        /// <summary>
        /// The entity is accessible both everywhere in the project content, and in all derived classes.
        /// </summary>
        /// <remarks>This corresponds to C# 'protected internal'.</remarks>
        ProtectedOrInternal,
        /// <summary>
        /// The entity is accessible in derived classes within the same project content.
        /// </summary>
        /// <remarks>C# does not support this accessibility.</remarks>
        ProtectedAndInternal,
    }

    public interface IHasAccessibility
    {
        /// <summary>
        /// Gets the accessibility of this entity.
        /// </summary>
        Accessibility Accessibility { get; }

        /// <summary>
        /// Gets a value indicating whether this instance is private.
        /// </summary>
        /// <value>
        /// <c>true</c> if this instance is private; otherwise, <c>false</c>.
        /// </value>
        bool IsPrivate { get; }

        /// <summary>
        /// Gets a value indicating whether this instance is public.
        /// </summary>
        /// <value>
        /// <c>true</c> if this instance is public; otherwise, <c>false</c>.
        /// </value>
        bool IsPublic { get; }

        /// <summary>
        /// Gets a value indicating whether this instance is protected.
        /// </summary>
        /// <value>
        /// <c>true</c> if this instance is protected; otherwise, <c>false</c>.
        /// </value>
        bool IsProtected { get; }

        /// <summary>
        /// Gets a value indicating whether this instance is internal.
        /// </summary>
        /// <value>
        /// <c>true</c> if this instance is internal; otherwise, <c>false</c>.
        /// </value>
        bool IsInternal { get; }

        /// <summary>
        /// Gets a value indicating whether this instance is protected or internal.
        /// </summary>
        /// <value>
        /// <c>true</c> if this instance is protected or internal; otherwise, <c>false</c>.
        /// </value>
        bool IsProtectedOrInternal { get; }

        /// <summary>
        /// Gets a value indicating whether this instance is protected and internal.
        /// </summary>
        /// <value>
        /// <c>true</c> if this instance is protected and internal; otherwise, <c>false</c>.
        /// </value>
        bool IsProtectedAndInternal { get; }
    }
    /// <summary>
    /// Represents some well-known types.
    /// </summary>
    public enum KnownTypeCode
    {
        // Note: DefaultResolvedTypeDefinition uses (KnownTypeCode)-1 as special value for "not yet calculated".
        // The order of type codes at the beginning must correspond to those in System.TypeCode.

        /// <summary>
        /// Not one of the known types.
        /// </summary>
        None,
        /// <summary><c>object</c> (System.Object)</summary>
        Object,
        /// <summary><c>bool</c> (System.Boolean)</summary>
        Boolean,
        /// <summary><c>char</c> (System.Char)</summary>
        Char,
        /// <summary><c>sbyte</c> (System.SByte)</summary>
        SByte,
        /// <summary><c>byte</c> (System.Byte)</summary>
        Byte,
        /// <summary><c>short</c> (System.Int16)</summary>
        Int16,
        /// <summary><c>ushort</c> (System.UInt16)</summary>
        UInt16,
        /// <summary><c>int</c> (System.Int32)</summary>
        Int32,
        /// <summary><c>uint</c> (System.UInt32)</summary>
        UInt32,
        /// <summary><c>long</c> (System.Int64)</summary>
        Int64,
        /// <summary><c>ulong</c> (System.UInt64)</summary>
        UInt64,
        /// <summary><c>float</c> (System.Single)</summary>
        Single,
        /// <summary><c>double</c> (System.Double)</summary>
        Double,
        /// <summary><c>string</c> (System.String)</summary>
        String,
        /// <summary><c>void</c> (System.Void)</summary>
        Void,
       
    }

    /// <summary>
    /// Holds the full name of a type definition.
    /// A full type name uniquely identifies a type definition within a single assembly.
    /// </summary>
    /// <remarks>
    /// A full type name can only represent type definitions, not arbitrary types.
    /// It does not include any type arguments, and can not refer to array or pointer types.
    /// 
    /// A full type name represented as reflection name has the syntax:
    /// <c>NamespaceName '.' TopLevelTypeName ['`'#] { '+' NestedTypeName ['`'#] }</c>
    /// </remarks>
    [Serializable]
    public struct FullTypeName : IEquatable<FullTypeName>
    {
        [Serializable]
        struct NestedTypeName
        {
            public readonly string Name;
            public readonly int AdditionalTypeParameterCount;

            public NestedTypeName(string name, int additionalTypeParameterCount)
            {
                if (name == null)
                    throw new ArgumentNullException("name");
                this.Name = name;
                this.AdditionalTypeParameterCount = additionalTypeParameterCount;
            }
        }

        readonly TopLevelTypeName topLevelType;
        readonly NestedTypeName[] nestedTypes;

        FullTypeName(TopLevelTypeName topLevelTypeName, NestedTypeName[] nestedTypes)
        {
            this.topLevelType = topLevelTypeName;
            this.nestedTypes = nestedTypes;
        }

        /// <summary>
        /// Constructs a FullTypeName representing the given top-level type.
        /// </summary>
        /// <remarks>
        /// FullTypeName has an implicit conversion operator from TopLevelTypeName,
        /// so you can simply write:
        /// <c>FullTypeName f = new TopLevelTypeName(...);</c>
        /// </remarks>
        public FullTypeName(TopLevelTypeName topLevelTypeName)
        {
            this.topLevelType = topLevelTypeName;
            this.nestedTypes = null;
        }

        /// <summary>
        /// Constructs a FullTypeName by parsing the given reflection name.
        /// Note that FullTypeName can only represent type definition names. If the reflection name
        /// might refer to a parameterized type or array etc., use
        /// <see cref="ReflectionHelper.ParseReflectionName(string)"/> instead.
        /// </summary>
        /// <remarks>
        /// Expected syntax: <c>NamespaceName '.' TopLevelTypeName ['`'#] { '+' NestedTypeName ['`'#] }</c>
        /// where # are type parameter counts
        /// </remarks>
        public FullTypeName(string reflectionName)
        {
            int pos = reflectionName.IndexOf('+');
            if (pos < 0)
            {
                // top-level type
                this.topLevelType = new TopLevelTypeName(reflectionName);
                this.nestedTypes = null;
            }
            else
            {
                // nested type
                string[] parts = reflectionName.Split('+');
                this.topLevelType = new TopLevelTypeName(parts[0]);
                this.nestedTypes = new NestedTypeName[parts.Length - 1];
                for (int i = 0; i < nestedTypes.Length; i++)
                {
                    int tpc;
                    string name = ReflectionHelper.SplitTypeParameterCountFromReflectionName(parts[i + 1], out tpc);
                    nestedTypes[i] = new NestedTypeName(name, tpc);
                }
            }
        }

        /// <summary>
        /// Gets the top-level type name.
        /// </summary>
        public TopLevelTypeName TopLevelTypeName
        {
            get { return topLevelType; }
        }

        /// <summary>
        /// Gets whether this is a nested type.
        /// </summary>
        public bool IsNested
        {
            get
            {
                return nestedTypes != null;
            }
        }

        /// <summary>
        /// Gets the nesting level.
        /// </summary>
        public int NestingLevel
        {
            get
            {
                return nestedTypes != null ? nestedTypes.Length : 0;
            }
        }

        /// <summary>
        /// Gets the name of the type.
        /// For nested types, this is the name of the innermost type.
        /// </summary>
        public string Name
        {
            get
            {
                if (nestedTypes != null)
                    return nestedTypes[nestedTypes.Length - 1].Name;
                else
                    return topLevelType.Name;
            }
        }

        public string ReflectionName
        {
            get
            {
                if (nestedTypes == null)
                    return topLevelType.ReflectionName;
                StringBuilder b = new StringBuilder(topLevelType.ReflectionName);
                foreach (NestedTypeName nt in nestedTypes)
                {
                    b.Append('+');
                    b.Append(nt.Name);
                    if (nt.AdditionalTypeParameterCount > 0)
                    {
                        b.Append('`');
                        b.Append(nt.AdditionalTypeParameterCount);
                    }
                }
                return b.ToString();
            }
        }

        /// <summary>
        /// Gets the total type parameter count.
        /// </summary>
        public int TypeParameterCount
        {
            get
            {
                int tpc = topLevelType.TypeParameterCount;
                if (nestedTypes != null)
                {
                    foreach (var nt in nestedTypes)
                    {
                        tpc += nt.AdditionalTypeParameterCount;
                    }
                }
                return tpc;
            }
        }

        /// <summary>
        /// Gets the name of the nested type at the given level.
        /// </summary>
        public string GetNestedTypeName(int nestingLevel)
        {
            if (nestedTypes == null)
                throw new InvalidOperationException();
            return nestedTypes[nestingLevel].Name;
        }

        /// <summary>
        /// Gets the number of additional type parameters of the nested type at the given level.
        /// </summary>
        public int GetNestedTypeAdditionalTypeParameterCount(int nestingLevel)
        {
            if (nestedTypes == null)
                throw new InvalidOperationException();
            return nestedTypes[nestingLevel].AdditionalTypeParameterCount;
        }

        /// <summary>
        /// Gets the declaring type name.
        /// </summary>
        /// <exception cref="InvalidOperationException">This is a top-level type name.</exception>
        /// <example><c>new FullTypeName("NS.A+B+C").GetDeclaringType()</c> will return <c>new FullTypeName("NS.A+B")</c></example>
        public FullTypeName GetDeclaringType()
        {
            if (nestedTypes == null)
                throw new InvalidOperationException();
            if (nestedTypes.Length == 1)
                return topLevelType;
            NestedTypeName[] outerNestedTypeNames = new NestedTypeName[nestedTypes.Length - 1];
            Array.Copy(nestedTypes, 0, outerNestedTypeNames, 0, outerNestedTypeNames.Length);
            return new FullTypeName(topLevelType, nestedTypes);
        }

        /// <summary>
        /// Creates a nested type name.
        /// </summary>
        /// <example><c>new FullTypeName("NS.A+B").NestedType("C", 1)</c> will return <c>new FullTypeName("NS.A+B+C`1")</c></example>
        public FullTypeName NestedType(string name, int additionalTypeParameterCount)
        {
            if (name == null)
                throw new ArgumentNullException("name");
            var newNestedType = new NestedTypeName(name, additionalTypeParameterCount);
            if (nestedTypes == null)
                return new FullTypeName(topLevelType, new[] { newNestedType });
            NestedTypeName[] newNestedTypeNames = new NestedTypeName[nestedTypes.Length + 1];
            nestedTypes.CopyTo(newNestedTypeNames, 0);
            newNestedTypeNames[newNestedTypeNames.Length - 1] = newNestedType;
            return new FullTypeName(topLevelType, newNestedTypeNames);
        }

        public static implicit operator FullTypeName(TopLevelTypeName topLevelTypeName)
        {
            return new FullTypeName(topLevelTypeName);
        }

        public override string ToString()
        {
            return this.ReflectionName;
        }

        #region Equals and GetHashCode implementation
        public override bool Equals(object obj)
        {
            return obj is FullTypeName && Equals((FullTypeName)obj);
        }

        public bool Equals(FullTypeName other)
        {
            return FullTypeNameComparer.Ordinal.Equals(this, other);
        }

        public override int GetHashCode()
        {
            return FullTypeNameComparer.Ordinal.GetHashCode(this);
        }

        public static bool operator ==(FullTypeName left, FullTypeName right)
        {
            return left.Equals(right);
        }

        public static bool operator !=(FullTypeName left, FullTypeName right)
        {
            return !left.Equals(right);
        }
        #endregion
    }

    [Serializable]
    public sealed class FullTypeNameComparer : IEqualityComparer<FullTypeName>
    {
        public static readonly FullTypeNameComparer Ordinal = new FullTypeNameComparer(StringComparer.Ordinal);
        public static readonly FullTypeNameComparer OrdinalIgnoreCase = new FullTypeNameComparer(StringComparer.OrdinalIgnoreCase);

        public readonly StringComparer NameComparer;

        public FullTypeNameComparer(StringComparer nameComparer)
        {
            this.NameComparer = nameComparer;
        }

        public bool Equals(FullTypeName x, FullTypeName y)
        {
            if (x.NestingLevel != y.NestingLevel)
                return false;
            TopLevelTypeName topX = x.TopLevelTypeName;
            TopLevelTypeName topY = y.TopLevelTypeName;
            if (topX.TypeParameterCount == topY.TypeParameterCount
                && NameComparer.Equals(topX.Name, topY.Name)
                && NameComparer.Equals(topX.Namespace, topY.Namespace))
            {
                for (int i = 0; i < x.NestingLevel; i++)
                {
                    if (x.GetNestedTypeAdditionalTypeParameterCount(i) != y.GetNestedTypeAdditionalTypeParameterCount(i))
                        return false;
                    if (!NameComparer.Equals(x.GetNestedTypeName(i), y.GetNestedTypeName(i)))
                        return false;
                }
                return true;
            }
            return false;
        }

        public int GetHashCode(FullTypeName obj)
        {
            TopLevelTypeName top = obj.TopLevelTypeName;
            int hash = NameComparer.GetHashCode(top.Name) ^ NameComparer.GetHashCode(top.Namespace) ^ top.TypeParameterCount;
            unchecked
            {
                for (int i = 0; i < obj.NestingLevel; i++)
                {
                    hash *= 31;
                    hash += NameComparer.GetHashCode(obj.Name) ^ obj.TypeParameterCount;
                }
            }
            return hash;
        }
    }
    /// <summary>
    /// Holds the name of a top-level type.
    /// This struct cannot refer to nested classes.
    /// </summary>
    [Serializable]
    public struct TopLevelTypeName : IEquatable<TopLevelTypeName>
    {
        readonly string namespaceName;
        readonly string name;
        readonly int typeParameterCount;

        public TopLevelTypeName(string namespaceName, string name, int typeParameterCount = 0)
        {
            if (namespaceName == null)
                throw new ArgumentNullException("namespaceName");
            if (name == null)
                throw new ArgumentNullException("name");
            this.namespaceName = namespaceName;
            this.name = name;
            this.typeParameterCount = typeParameterCount;
        }

        public TopLevelTypeName(string reflectionName)
        {
            int pos = reflectionName.LastIndexOf('.');
            if (pos < 0)
            {
                namespaceName = string.Empty;
                name = reflectionName;
            }
            else
            {
                namespaceName = reflectionName.Substring(0, pos);
                name = reflectionName.Substring(pos + 1);
            }
            name = ReflectionHelper.SplitTypeParameterCountFromReflectionName(name, out typeParameterCount);
        }

        public string Namespace
        {
            get { return namespaceName; }
        }

        public string Name
        {
            get { return name; }
        }

        public int TypeParameterCount
        {
            get { return typeParameterCount; }
        }

        public string ReflectionName
        {
            get
            {
                StringBuilder b = new StringBuilder();
                if (!string.IsNullOrEmpty(namespaceName))
                {
                    b.Append(namespaceName);
                    b.Append('.');
                }
                b.Append(name);
                if (typeParameterCount > 0)
                {
                    b.Append('`');
                    b.Append(typeParameterCount);
                }
                return b.ToString();
            }
        }

        public override string ToString()
        {
            return this.ReflectionName;
        }

        public override bool Equals(object obj)
        {
            return (obj is TopLevelTypeName) && Equals((TopLevelTypeName)obj);
        }

        public bool Equals(TopLevelTypeName other)
        {
            return this.namespaceName == other.namespaceName && this.name == other.name && this.typeParameterCount == other.typeParameterCount;
        }

        public override int GetHashCode()
        {
            return (name != null ? name.GetHashCode() : 0) ^ (namespaceName != null ? namespaceName.GetHashCode() : 0) ^ typeParameterCount;
        }

        public static bool operator ==(TopLevelTypeName lhs, TopLevelTypeName rhs)
        {
            return lhs.Equals(rhs);
        }

        public static bool operator !=(TopLevelTypeName lhs, TopLevelTypeName rhs)
        {
            return !lhs.Equals(rhs);
        }
    }

    [Serializable]
    public sealed class TopLevelTypeNameComparer : IEqualityComparer<TopLevelTypeName>
    {
        public static readonly TopLevelTypeNameComparer Ordinal = new TopLevelTypeNameComparer(StringComparer.Ordinal);
        public static readonly TopLevelTypeNameComparer OrdinalIgnoreCase = new TopLevelTypeNameComparer(StringComparer.OrdinalIgnoreCase);

        public readonly StringComparer NameComparer;

        public TopLevelTypeNameComparer(StringComparer nameComparer)
        {
            this.NameComparer = nameComparer;
        }

        public bool Equals(TopLevelTypeName x, TopLevelTypeName y)
        {
            return x.TypeParameterCount == y.TypeParameterCount
                && NameComparer.Equals(x.Name, y.Name)
                && NameComparer.Equals(x.Namespace, y.Namespace);
        }

        public int GetHashCode(TopLevelTypeName obj)
        {
            return NameComparer.GetHashCode(obj.Name) ^ NameComparer.GetHashCode(obj.Namespace) ^ obj.TypeParameterCount;
        }
    }
    /// <summary>
    /// .
    /// </summary>
    public enum TypeKind : byte
    {
        /// <summary>Language-specific type that is not part of NRefactory.TypeSystem itself.</summary>
        Other,

        /// <summary>A <see cref="ITypeDefinition"/> or <see cref="ParameterizedType"/> that is a class.</summary>
        Class,
        /// <summary>A <see cref="ITypeDefinition"/> or <see cref="ParameterizedType"/> that is an interface.</summary>
        Interface,
        /// <summary>A <see cref="ITypeDefinition"/> or <see cref="ParameterizedType"/> that is a struct.</summary>
        Struct,
        /// <summary>A <see cref="ITypeDefinition"/> or <see cref="ParameterizedType"/> that is a delegate.</summary>
        /// <remarks><c>System.Delegate</c> itself is TypeKind.Class</remarks>
        Delegate,
        /// <summary>A <see cref="ITypeDefinition"/> that is an enum.</summary>
        /// <remarks><c>System.Enum</c> itself is TypeKind.Class</remarks>
        Enum,

        /// <summary>The <c>System.Void</c> type.</summary>
        /// <see cref="KnownTypeReference.Void"/>
        Void,

        /// <see cref="SpecialTypeSpec.UnknownType"/>
        Unknown,
        /// <summary>The type of the null literal.</summary>
        /// <see cref="SpecialTypeSpec.NullType"/>
        Null,
        /// <summary>Represents missing type arguments in partially parameterized types.</summary>
        /// <see cref="SpecialTypeSpec.UnboundTypeArgument"/>
        /// <see cref="IType.GetNestedTypes(Predicate{ITypeDefinition}, GetMemberOptions)"/>
        UnboundTypeArgument,

        /// <summary>The type is a type parameter.</summary>
        /// <see cref="ITypeParameter"/>
        TypeParameter,

        /// <summary>An array type</summary>
        /// <see cref="ArrayType"/>
        Array,
        /// <summary>A pointer type</summary>
        /// <see cref="PointerType"/>
        Pointer,
        /// <summary>A managed reference type</summary>
        /// <see cref="NullableType"/>
        ByReference,
        /// <summary>An anonymous type</summary>
        /// <see cref="AnonymousType"/>
        Anonymous,
        /// <summary>Intersection of several types</summary>
        /// <see cref="IntersectionType"/>
        Intersection,

    }

    /// <summary>
    /// Contains well-known type references.
    /// </summary>
    [Serializable]
    public sealed class KnownTypeReference : ITypeReference
    {
        internal const int KnownTypeCodeCount = (int)KnownTypeCode.Void + 2;

        static readonly KnownTypeReference[] knownTypeReferences = new KnownTypeReference[KnownTypeCodeCount] {
			null, // None
			new KnownTypeReference(KnownTypeCode.Object,   "System", "Object", baseType: KnownTypeCode.None),
			new KnownTypeReference(KnownTypeCode.Boolean,  "System", "Boolean",  baseType: KnownTypeCode.Object),
			new KnownTypeReference(KnownTypeCode.Char,     "System", "Char",     baseType: KnownTypeCode.Object),
			new KnownTypeReference(KnownTypeCode.SByte,    "System", "SByte",    baseType: KnownTypeCode.Object),
			new KnownTypeReference(KnownTypeCode.Byte,     "System", "Byte",     baseType: KnownTypeCode.Object),
			new KnownTypeReference(KnownTypeCode.Int16,    "System", "Int16",    baseType: KnownTypeCode.Object),
			new KnownTypeReference(KnownTypeCode.UInt16,   "System", "UInt16",   baseType: KnownTypeCode.Object),
			new KnownTypeReference(KnownTypeCode.Int32,    "System", "Int32",    baseType: KnownTypeCode.Object),
			new KnownTypeReference(KnownTypeCode.UInt32,   "System", "UInt32",   baseType: KnownTypeCode.Object),
			new KnownTypeReference(KnownTypeCode.Int64,    "System", "Int64",    baseType: KnownTypeCode.Object),
			new KnownTypeReference(KnownTypeCode.UInt64,   "System", "UInt64",   baseType: KnownTypeCode.Object),
			new KnownTypeReference(KnownTypeCode.Single,   "System", "Single",   baseType: KnownTypeCode.Object),
			new KnownTypeReference(KnownTypeCode.Double,   "System", "Double",   baseType: KnownTypeCode.Object),
		    new KnownTypeReference(KnownTypeCode.Single,   "System", "Single",   baseType: KnownTypeCode.Object),
			new KnownTypeReference(KnownTypeCode.String,    "System", "String"),
			new KnownTypeReference(KnownTypeCode.Void,      "System", "Void"),

		};

        /// <summary>
        /// Gets the known type reference for the specified type code.
        /// Returns null for KnownTypeCode.None.
        /// </summary>
        public static KnownTypeReference Get(KnownTypeCode typeCode)
        {
            return knownTypeReferences[(int)typeCode];
        }

        /// <summary>
        /// Gets a type reference pointing to the <c>object</c> type.
        /// </summary>
        public static readonly KnownTypeReference Object = Get(KnownTypeCode.Object);

        /// <summary>
        /// Gets a type reference pointing to the <c>bool</c> type.
        /// </summary>
        public static readonly KnownTypeReference Boolean = Get(KnownTypeCode.Boolean);

        /// <summary>
        /// Gets a type reference pointing to the <c>char</c> type.
        /// </summary>
        public static readonly KnownTypeReference Char = Get(KnownTypeCode.Char);

        /// <summary>
        /// Gets a type reference pointing to the <c>sbyte</c> type.
        /// </summary>
        public static readonly KnownTypeReference SByte = Get(KnownTypeCode.SByte);

        /// <summary>
        /// Gets a type reference pointing to the <c>byte</c> type.
        /// </summary>
        public static readonly KnownTypeReference Byte = Get(KnownTypeCode.Byte);

        /// <summary>
        /// Gets a type reference pointing to the <c>short</c> type.
        /// </summary>
        public static readonly KnownTypeReference Int16 = Get(KnownTypeCode.Int16);

        /// <summary>
        /// Gets a type reference pointing to the <c>ushort</c> type.
        /// </summary>
        public static readonly KnownTypeReference UInt16 = Get(KnownTypeCode.UInt16);

        /// <summary>
        /// Gets a type reference pointing to the <c>int</c> type.
        /// </summary>
        public static readonly KnownTypeReference Int32 = Get(KnownTypeCode.Int32);

        /// <summary>
        /// Gets a type reference pointing to the <c>uint</c> type.
        /// </summary>
        public static readonly KnownTypeReference UInt32 = Get(KnownTypeCode.UInt32);

        /// <summary>
        /// Gets a type reference pointing to the <c>long</c> type.
        /// </summary>
        public static readonly KnownTypeReference Int64 = Get(KnownTypeCode.Int64);

        /// <summary>
        /// Gets a type reference pointing to the <c>ulong</c> type.
        /// </summary>
        public static readonly KnownTypeReference UInt64 = Get(KnownTypeCode.UInt64);

        /// <summary>
        /// Gets a type reference pointing to the <c>float</c> type.
        /// </summary>
        public static readonly KnownTypeReference Single = Get(KnownTypeCode.Single);

        /// <summary>
        /// Gets a type reference pointing to the <c>double</c> type.
        /// </summary>
        public static readonly KnownTypeReference Double = Get(KnownTypeCode.Double);

  

        /// <summary>
        /// Gets a type reference pointing to the <c>string</c> type.
        /// </summary>
        public static readonly KnownTypeReference String = Get(KnownTypeCode.String);

        /// <summary>
        /// Gets a type reference pointing to the <c>void</c> type.
        /// </summary>
        public static readonly KnownTypeReference Void = Get(KnownTypeCode.Void);


        readonly KnownTypeCode knownTypeCode;
        readonly string namespaceName;
        readonly string name;
        readonly int typeParameterCount;
        internal readonly KnownTypeCode baseType;

        private KnownTypeReference(KnownTypeCode knownTypeCode, string namespaceName, string name, int typeParameterCount = 0, KnownTypeCode baseType = KnownTypeCode.Object)
        {
            this.knownTypeCode = knownTypeCode;
            this.namespaceName = namespaceName;
            this.name = name;
            this.typeParameterCount = typeParameterCount;
            this.baseType = baseType;
        }

        public KnownTypeCode KnownTypeCode
        {
            get { return knownTypeCode; }
        }

        public string Namespace
        {
            get { return namespaceName; }
        }

        public string Name
        {
            get { return name; }
        }

        public int TypeParameterCount
        {
            get { return typeParameterCount; }
        }

        public IType Resolve(ITypeResolveContext context)
        {
            return context.Compilation.FindType(knownTypeCode);
        }

        public override string ToString()
        {
            return GetVSNameByTypeCode(knownTypeCode) ?? (this.Namespace + "." + this.Name);
        }

        /// <summary>
        /// Gets the V# primitive type name from the known type code.
        /// Returns null if there is no primitive name for the specified type.
        /// </summary>
        public static string GetVSNameByTypeCode(KnownTypeCode knownTypeCode)
        {
            switch (knownTypeCode)
            {
                case KnownTypeCode.Object:
                    return "object";
                case KnownTypeCode.Boolean:
                    return "bool";
                case KnownTypeCode.Char:
                    return "char";
                case KnownTypeCode.SByte:
                    return "sbyte";
                case KnownTypeCode.Byte:
                    return "byte";
                case KnownTypeCode.Int16:
                    return "short";
                case KnownTypeCode.UInt16:
                    return "ushort";
                case KnownTypeCode.Int32:
                    return "int";
                case KnownTypeCode.UInt32:
                    return "uint";
                case KnownTypeCode.Int64:
                    return "long";
                case KnownTypeCode.UInt64:
                    return "ulong";
                case KnownTypeCode.Single:
                    return "float";
                case KnownTypeCode.Double:
                    return "double";
                case KnownTypeCode.String:
                    return "string";
                case KnownTypeCode.Void:
                    return "void";
                default:
                    return null;
            }
        }
    }
}
