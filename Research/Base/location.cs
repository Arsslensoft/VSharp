using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

namespace VSC
{
 
	//
	//  This is one single source file.
	//
	public class SourceFile : IEquatable<SourceFile>
	{
        //
        // Used by #line directive to track hidden sequence point
        // regions
        //
        struct LocationRegion : IComparable<LocationRegion>
        {
            public readonly Location Start;
            public readonly Location End;

            public LocationRegion(Location start, Location end)
            {
                this.Start = start;
                this.End = end;
            }

            public int CompareTo(LocationRegion other)
            {
                if (Start.Line == other.Start.Line)
                    return Start.Column.CompareTo(other.Start.Column);

                return Start.Line.CompareTo(other.Start.Line);
            }

            public override string ToString()
            {
                return Start.ToString() + " - " + End.ToString();
            }
        }
        public void RegisterHiddenScope(Location start, Location end)
        {
            if (hidden_lines == null)
                hidden_lines = new List<LocationRegion>();

            hidden_lines.Add(new LocationRegion(start, end));
        }

		static readonly byte[] MD5Algorith = { 96, 166, 110, 64, 207, 100, 130, 76, 182, 240, 66, 212, 129, 114, 167, 153 };

		public readonly string Name;
		public readonly string FullPathName;
		public readonly int Index;
		public bool AutoGenerated;

		byte[] algGuid, checksum;
        List<LocationRegion> hidden_lines;
        public static SourceFile Null = new SourceFile("<null>", "null", 0);
		public SourceFile (string name, string path, int index)
		{
			this.Index = index;
			this.Name = name;
			this.FullPathName = path;
		}

		public byte[] Checksum {
			get {
				return checksum;
			}
		}

		public bool HasChecksum {
			get {
				return checksum != null;
			}
		}


		public void SetChecksum (byte[] checksum)
		{
			SetChecksum (MD5Algorith, checksum);
		}

		public void SetChecksum (byte[] algorithmGuid, byte[] checksum)
		{
			this.algGuid = algorithmGuid;
			this.checksum = checksum;
		}
		public bool Equals (SourceFile other)
		{
			return FullPathName == other.FullPathName;
		}

		public override string ToString ()
		{
			return String.Format ("SourceFile ({0}:{1}:{2})", Name, FullPathName, Index);
		}
	}

	/// <summary>
	///   Keeps track of the location in the program
	/// </summary>
	///
	/// <remarks>
	///   This uses a compact representation and a couple of auxiliary
	///   structures to keep track of tokens to (file,line and column) 
	///   mappings. The usage of the bits is:
	///   
	///     - 16 bits for "checkpoint" which is a mixed concept of
	///       file and "line segment"
	///     - 8 bits for line delta (offset) from the line segment
	///     - 8 bits for column number.
	///
	///   http://lists.ximian.com/pipermail/mono-devel-list/2004-December/009508.html
	/// </remarks>
	public struct Location : IEquatable<Location>, IComparable<Location>
	{


        SourceFile file;
		public readonly static Location Null = new Location ();

	
        public Location (int row, int column)
            :this(SourceFile.Null,row,column)
        {
           
        }
		public Location (SourceFile file, int row, int column)
		{
            this.file = file;
            line = row;
            this.column = column;
		}

		public static Location operator - (Location loc, int columns)
		{
			return new Location (loc.SourceFile, loc.Line, loc.Column - columns);
		}
        public static bool operator ==(Location loc, Location l)
        {
            return loc.file == l.file && l.Column == loc.Column && l.Line == loc.Line;
        }
        /// <summary>
        /// Compares two text locations.
        /// </summary>
        public static bool operator <(Location left, Location right)
        {
            if (left.line < right.line)
                return true;
            else if (left.line == right.line)
                return left.column < right.column;
            else
                return false;
        }

        /// <summary>
        /// Compares two text locations.
        /// </summary>
        public static bool operator >(Location left, Location right)
        {
            if (left.line > right.line)
                return true;
            else if (left.line == right.Line)
                return left.column > right.column;
            else
                return false;
        }

        /// <summary>
        /// Compares two text locations.
        /// </summary>
        public static bool operator <=(Location left, Location right)
        {
            return !(left > right);
        }

        /// <summary>
        /// Compares two text locations.
        /// </summary>
        public static bool operator >=(Location left, Location right)
        {
            return !(left < right);
        }

        /// <summary>
        /// Compares two text locations.
        /// </summary>
        public int CompareTo(Location other)
        {
            if (this == other)
                return 0;
            if (this < other)
                return -1;
            else
                return 1;
        }
        public static bool operator !=(Location loc, Location l)
        {
            return loc.file != l.file || l.Column != loc.Column || l.Line != loc.Line;
        }
	

		string FormatLocation (string fileName)
		{

            return fileName + "(" + Line.ToString() + "," + Column.ToString();
				

		}
		
		public override string ToString ()
		{
			return FormatLocation (Name);
		}

		public string ToStringFullName ()
		{
			return FormatLocation (NameFullPath);
		}
		
		/// <summary>
		///   Whether the Location is Null
		/// </summary>
		public bool IsNull {
			get { return line == 0 && column == 0; }
		}

		public string Name {
			get {
				
				return file.Name;
			}
		}
        public SourceFile File
        {
            get { return file; }
        }
		public string NameFullPath {
			get {
                return File.FullPathName;
			}
		}

	


        int column, line;

        /// <summary>
        /// Gets the line number.
        /// </summary>
        public int Line
        {
            get { return line; }
        }

        /// <summary>
        /// Gets the column number.
        /// </summary>
        public int Column
        {
            get { return column; }
        }
	

		// The ISymbolDocumentWriter interface is used by the symbol writer to
		// describe a single source file - for each source file there's exactly
		// one corresponding ISymbolDocumentWriter instance.
		//
		// This class has an internal hash table mapping source document names
		// to such ISymbolDocumentWriter instances - so there's exactly one
		// instance per document.
		//
		// This property returns the ISymbolDocumentWriter instance which belongs
		// to the location's source file.
		//
		// If we don't have a symbol writer, this property is always null.
		public SourceFile SourceFile {
			get {
                return File;
			}
		}

		#region IEquatable<Location> Members

		public bool Equals (Location other)
		{
			return this == other;
		}

		#endregion
	}
	
	
}
